# Blender 4.3以降の命名衝突管理

## 1. 各データの名前空間と命名衝突回避の仕組み

**Blenderのデータブロックごとの名前空間:**  
Blenderでは**データブロック (Data-block)** と呼ばれる各種データ（オブジェクト、コレクション、マテリアル、メッシュ、カーブ、メタボール、ボリューム、グリースペンシル、アーマチュア、ラティス、ライト、ライトプローブ、カメラ、スピーカー、シーン、ブラシなど）ごとに**名前空間**が分かれています ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Data,blendfile%20it%20is%20stored%20in))。同じ種類のデータブロック間では名前は一意でなければならず、重複が許されません。例えば、ひとつの.blendファイル内で**オブジェクト**同士は同名にできず、同名にしようとすると自動的にリネームされます。一方で**異なる種類**（例えばオブジェクトとメッシュ）の間であれば同じ名前を付けても問題ありません ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Data,blendfile%20it%20is%20stored%20in)) ([Consider warning on duplicate node names. · Issue #93 · KhronosGroup/glTF-Validator · GitHub](https://github.com/KhronosGroup/glTF-Validator/issues/93#:~:text=For%20reference%2C%20Blender%20names%20are,etc%20showing%20up))。実際、デフォルトのシーンには「Cube」というオブジェクトと「Cube」というメッシュデータが存在しますが、これは**オブジェクト**と**メッシュ**で種類が異なるため許容されています ([Consider warning on duplicate node names. · Issue #93 · KhronosGroup/glTF-Validator · GitHub](https://github.com/KhronosGroup/glTF-Validator/issues/93#:~:text=For%20reference%2C%20Blender%20names%20are,etc%20showing%20up))。

**ローカルデータとリンクデータ:**  
名前空間は「データの種類」と「それが属する.blendファイル」で定義されます ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Data,blendfile%20it%20is%20stored%20in))。そのため、同じ.blendファイル内では同種のローカルデータブロックは名前が重複しませんが、**リンク（外部ファイルからリンクされたデータ）**の場合は例外があります。Blenderでは**ローカル**なオブジェクトと**外部からリンクされた**オブジェクトが同じ名前を持つことが可能です ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=This%20means%20that%20there%20can,Objects%20sharing%20the%20same%20name))。つまり、自身のファイル内のオブジェクト同士は同名不可ですが、自分のファイルのオブジェクトと別ファイルからリンクしてきたオブジェクトが同名になるケースは許容されます（リンクデータには元ファイルでの名前を維持させ、無闇にリネームしない仕様） ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=This%20means%20that%20there%20can,Objects%20sharing%20the%20same%20name))。

**骨(Bone)、ノード、シーケンスストリップなど内包要素の名前空間:**  
上記の「データブロック」はBlender全体で管理される独立データですが、**Armature内のボーン**や**ノードツリー内のノード**、**ビデオエディタのシーケンスストリップ**などもそれぞれのコンテナ内で名前の一意性が求められます。例えば、Armatureデータ内のボーン同士は同名にできませんし、新規ボーン作成時には既存名と被らないよう自動で名前が付与されます ([Beginner tutorial: Character (rorbot) mod from scratch, in Blender | Page 2 | Rigs of Rods Community](https://forum.rigsofrods.org/threads/beginner-tutorial-character-rorbot-mod-from-scratch-in-blender.3761/page-2#:~:text=Step%2025%20,new%20bone))。ノードについても、同じノードツリー内で名前が重複すれば識別が難しくなるため、新規追加時に他のノード名と衝突すれば自動で「.001」付きの名称になります（Blenderのインポーター等も、重複ノード名があればBlender側で自動リネームされることを想定しています ([Consider warning on duplicate node names. · Issue #93 · KhronosGroup/glTF-Validator · GitHub](https://github.com/KhronosGroup/glTF-Validator/issues/93#:~:text=For%20reference%2C%20Blender%20names%20are,etc%20showing%20up))）。シーケンスストリップやアクションクリップ（NLAトラック上のアクション）も内部的には名前を持ち、同種の他要素と重複しないよう管理されています。

**命名衝突の回避:**  
Blenderは新しいデータブロック（やボーン等の内部要素）を追加したり、既存の名前を変更したりする際、自動的に**重複チェック**を行います ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=When%20Blender%20has%20to%20name,until%20no%20collision%20happen%20anymore))。もし同じ名前が既に存在する場合、Blenderはそのデータに**「.001」**のような番号付きサフィックスを末尾に追加してリネームします ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=When%20Blender%20has%20to%20name,until%20no%20collision%20happen%20anymore))。番号は基本的に**3桁**で、`.001`から`.999`までの中で**最小の利用可能な番号**が付与されます ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=When%20Blender%20has%20to%20name,until%20no%20collision%20happen%20anymore))。例えば、同じ種類で「Cube」という名前が既に使われている状態で新たに「Cube」を作成/改名しようとすると、自動で「Cube.001」が割り当てられます ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=Blender%20uses%20the%20name%20to,it%20finds%20an%20unused%20name))。さらに「Cube」「Cube.001」が存在する状態で新規追加すれば「Cube.002」のように、**既存の他のデータは変更せず**新しい番号を付けていきます ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Blender%20will%20never%20rename%20another,002))。最初の`.001`～`.999`がすべて埋まっている場合は`.1000`, `.1001`…と**999以降も番号を増やし続けて**衝突しない名前を確保します ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=When%20Blender%20has%20to%20name,until%20no%20collision%20happen%20anymore))。この際、名前が長すぎてサフィックスを付け足す余裕がない場合は、自動的に元の名前の一部を切り詰めてから番号を付与します ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=value%2C%20after%20that%20the%20postfix,until%20no%20collision%20happen%20anymore))。  

> ※上限63文字: Blenderの名前は内部的にUTF-8で最大63バイトに制限されています ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Data,than%20a%20byte%20per%20character)) ([outliner - What is the format for object names in Blender and are there any limitations? - Blender Stack Exchange](https://blender.stackexchange.com/questions/24245/what-is-the-format-for-object-names-in-blender-and-are-there-any-limitations#:~:text=Any%20ID%20name%20,use%20two%20bytes%20or%20more))。基本的な英数字なら63文字までですが、日本語などマルチバイト文字を含むと使用バイト数が増えるため、使える文字数は減少します ([outliner - What is the format for object names in Blender and are there any limitations? - Blender Stack Exchange](https://blender.stackexchange.com/questions/24245/what-is-the-format-for-object-names-in-blender-and-are-there-any-limitations#:~:text=Any%20ID%20name%20,use%20two%20bytes%20or%20more))。63バイトを超える名前にリネームしようとすると自動で切り詰められます。

**例:** Mont29（Blender開発者）も解説している通り、「各IDデータブロックの名前は同種の中で一意でなければならず、例えば`Cube`というオブジェクトがある状態で別のオブジェクトに同じ名前を付けようとすると、自動で`Cube.001`にリネームされる」仕様になっています ([outliner - What is the format for object names in Blender and are there any limitations? - Blender Stack Exchange](https://blender.stackexchange.com/questions/24245/what-is-the-format-for-object-names-in-blender-and-are-there-any-limitations#:~:text=1,texture%20with%20the%20same%20names))。これはマテリアルやテクスチャなど他のデータブロックでも同様です ([outliner - What is the format for object names in Blender and are there any limitations? - Blender Stack Exchange](https://blender.stackexchange.com/questions/24245/what-is-the-format-for-object-names-in-blender-and-are-there-any-limitations#:~:text=1,texture%20with%20the%20same%20names))。

## 2. PoseBoneとEditBoneの名前管理の仕組み（モードによる影響）

**Boneデータの3種類の構造:**  
Armatureの**ボーン（Bone）**は、Blender内部で3つの異なるデータ構造を持っています ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Edit%20Bones%2C%20Pose%20Bones%2C%20Bone%E2%80%A6,Bones%C2%B6))。1つは**編集モード(Edit Mode)**で扱われる`EditBone`、もう1つは**オブジェクト/ポーズモード(Object/Pose Mode)**での静的な骨情報である`Bone`（Armatureデータ内のボーン）、そしてポーズ状態を扱う`PoseBone`（オブジェクトに属するPoseデータ内のボーン）です ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Edit%20Bones%2C%20Pose%20Bones%2C%20Bone%E2%80%A6,Bones%C2%B6)) ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Note))。簡単にまとめると:

- **EditBone**: 編集モードでのみ存在するボーン。長さや接続関係、親子付け変更、新規追加や削除、**名前の変更**など骨構造自体を編集するための一時データです ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=,relationships%20to%20other%20bones%2C%20etc))。Edit Mode以外では`edit_bones`は空となりアクセスできません ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=,relationships%20to%20other%20bones%2C%20etc))。  

- **Bone（Armatureデータ内のボーン）**: オブジェクトモードやポーズモードで参照されるArmatureデータ内のボーン要素です ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Bones%20%28Object))。`Object.data.bones`からアクセスするボーンで、これはArmatureが持つ**実データ**としてのボーンです。頭(head)や尻尾(tail)位置などの幾何情報はオブジェクトモードでは読み取り専用ですが、**名前やDeform有無**など一部プロパティはモードに関係なく編集可能です ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=,only)) ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Accessible%20but%20read))。

- **PoseBone**: ポーズモードで扱われる、オブジェクト固有のボーン変形状態データです ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=,settings))。`Object.pose.bones`からアクセスするボーンで、実体はArmatureデータ内のBoneを参照しており ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Note))、現在の回転・位置・スケールやIK設定、制約など**アニメーション用の可変状態**を持ちます。**PoseBone自体は「Boneそのもの」ではなく**、「オブジェクトに付属する姿勢情報」と言えます ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Note))。

**名前管理と変更タイミング:**  
ボーンの名前はArmatureデータ内の`Bone`構造が持っており、基本的に**Armature内で一意**です。同じArmature内で2つのボーンが同名になることは許されず、新規ボーン作成時には他のボーンと被らない名前が自動設定されます。例えば、Edit ModeでボーンをExtrude（押し出して新規作成）すると、元のボーン名「Bone」に対し自動で「Bone.001」と命名されます ([Beginner tutorial: Character (rorbot) mod from scratch, in Blender | Page 2 | Rigs of Rods Community](https://forum.rigsofrods.org/threads/beginner-tutorial-character-rorbot-mod-from-scratch-in-blender.3761/page-2#:~:text=Step%2025%20,new%20bone))。これは他のデータ同様に番号付きで重複を避ける仕組みです。

- **EditBoneでのリネーム:** 編集モード中は`EditBone.name`プロパティを変更することでボーン名を変更できます。この変更は**即座にArmatureデータのBone名にも反映**されます（編集モードを抜けるときにArmatureデータに適用されるイメージです）。Blender UIでは、編集モード中にプロパティパネルのボーン名フィールドを編集するか、アウトライナー上でダブルクリックすることでボーン名を変更できます ([Naming — Blender Manual](https://docs.blender.org/manual/ko/2.90/animation/armatures/bones/editing/naming.html#:~:text=You%20can%20rename%20your%20bones%2C,clicking%20bones%20in%20the%20Outliner))。編集モード中にリネームすると、Armature内で重複があれば他のケース同様に自動でサフィックスが付与されます（あるいは既存ボーンとの**名前入れ替え**が発生する場合もあります。後述）。

- **PoseBoneでのリネーム:** ポーズモード（またはオブジェクトモード）でも**ボーン名を変更可能**です。アウトライナーでボーンを表示させダブルクリックでリネームしたり、PropertiesエディターのBoneタブに表示される名前フィールドを編集したりできます ([Naming — Blender Manual](https://docs.blender.org/manual/ko/2.90/animation/armatures/bones/editing/naming.html#:~:text=You%20can%20rename%20your%20bones%2C,clicking%20bones%20in%20the%20Outliner))。内部的にはArmatureデータ内のBone名を直接変更する操作になります。PoseBoneの`name`プロパティも存在し、これを書き換えることでも同様にArmature内Boneの名前が変更されます（スクリプトから`pose.bones["Bone"].name = "NewName"`のように操作するとArmature上のBone名が変更されます）。**編集モードに入らなくても名前変更が可能**な点で、ボーン名は位置や接続と違い制約が緩く、Blenderはこれを許可しています ([Naming — Blender Manual](https://docs.blender.org/manual/ko/2.90/animation/armatures/bones/editing/naming.html#:~:text=You%20can%20rename%20your%20bones%2C,clicking%20bones%20in%20the%20Outliner))。  

**名前変更時の同期と制約:**  
ボーン名を変更するときも、Blenderは他のボーンとの重複チェックを行い、必要なら自動で番号を付加します。例えばArmature内に「Bone」という名前が既にあり、別のボーンを「Bone」にリネームすると、自動的に「Bone.001」等に調整されます（もしくはUI経由の場合**名前のスワップ**が行われます。詳しくは後述の自動付与ロジックを参照）。  

**PoseBoneとEditBoneの差異:**  
重要なのは**どのモードでリネームしても最終的に変更されるのはArmatureデータ内のBone名**だという点です。EditBoneは一時的な編集用データですが、その.nameを変える操作はモード終了時にArmatureのBoneに伝播し、PoseBoneも常にArmatureのBone名を参照・変更します。したがって、**「どの段階で名前が確定するか」**という問いに対しては、新規ボーンの場合は編集モードで作成された瞬間に仮の名前（重複回避済みのもの）が与えられ、編集モード終了時にArmatureデータのBoneとして確定します。既存ボーンの名前変更は、編集モード中でもポーズモード中でも行えますが、いずれもArmature内のBone名を書き換える点で本質的には同じです。  

ただし注意として、**リンクされたArmatureデータ内のボーンは名前変更できません**（外部ライブラリデータのため）。また、ボーン名を変更すると、その名前に紐づく他データへの影響も考慮が必要です。例えばメッシュの頂点グループ名は自動では追従しないため、リギング後にボーン名を変更するとウェイトペイントの頂点グループ名がずれてしまうことがあります（BlenderはアニメーションのFカーブやアクションについてはボーン名変更時に自動でチャンネル名を更新する措置があります ([#97723 - Renaming bone in Edit Mode then undoing does not update animation channel/group names - blender - Blender Projects](https://developer.blender.org/T97723#:~:text=Short%20description%20of%20error%20Renaming,Mode%20rather%20than%20Edit%20Mode)) ([#97723 - Renaming bone in Edit Mode then undoing does not update animation channel/group names - blender - Blender Projects](https://developer.blender.org/T97723#:~:text=1,for%20Bone%20%E2%80%93%20as%20expected))が、頂点グループは手動対応となります）。従って、スクリプトで一括改名する場合などは、関連データのケアも必要です。

## 3. 名前衝突時のBlenderの自動リネームロジック (“.001” など)

**自動サフィックス付与のアルゴリズム:**  
Blenderは名前の衝突を検知すると、自動で**「.数字」**のサフィックスを付加してユニークな名前を生成します ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=When%20Blender%20has%20to%20name,until%20no%20collision%20happen%20anymore))。基本的な動作は以下のとおりです:

- **新規データ作成時:**  新しくオブジェクト等を追加する際、指定されたデフォルト名（例えばメッシュオブジェクトなら“Cube”など）が既に存在する場合、自動で「.001」が付いた名前になります ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=Blender%20uses%20the%20name%20to,it%20finds%20an%20unused%20name))。例えば、シーンに「Cube」が存在している状態で新たにメッシュオブジェクトを追加すると、自動的に「Cube.001」という名前が与えられます。これはBlender内部で**最初に見つかった空き番号**を探して付与しているためです ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=When%20Blender%20has%20to%20name,until%20no%20collision%20happen%20anymore))。先に「Cube.001」が存在し「Cube.002」が空いていれば次は「Cube.002」が使われる、といった具合に**穴埋め方式**で番号が振られます。999まで到達してもなお重複すれば1000番以降も拡張されます ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=check%20for%20name%20collisions,until%20no%20collision%20happen%20anymore))。

- **既存データのリネーム時:**  ユーザーが既存データブロックの名前を変更する場合も同様に衝突チェックが働きます。ただし、**リネーム操作の場合には特殊な挙動**が追加されています。Blender 4.1以降、名前変更時の挙動は以下の2通りに分かれます ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=behavior%20in%20case%20of%20name,collision%20is%20as%20follow)) ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly)):

  1. **ルート名が異なる名前への変更:**  元の名前のベース部分（数字やピリオドを除いた部分）と、新しく付けようとする名前のベース部分が異なる場合です。この場合、単純に「新しい名前」を適用しようとし、もしそれで衝突が起これば**そのデータに対して**最初の空き番号を付与します ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,the%20first%20available%20numerical%20suffix))。他の既存データの名前は変えず、変更対象のみ「.001」等が付いた新名になります ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,the%20first%20available%20numerical%20suffix))。  
     *例:* シーン内に「Sphere」「Cube」「Cube.001」というオブジェクトがある状態で、「Sphere」を「Cube」にリネームしようとすると、既に「Cube」が存在するため対象の「Sphere」が**「Cube.002」**にリネームされます ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,the%20first%20available%20numerical%20suffix)) ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20to%20Cube.002))（このとき元の「Cube」「Cube.001」には変化なし）。  

  2. **ルート名が同じ名前への変更:**  元の名前がすでに「名前.番号」の形式で、そのベース部分を既存の同名ベースに変更しようとする場合です ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly))。このケースではBlenderは**衝突する相手との名前スワップ**を行います ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly))。つまり、変更対象のデータブロックにはユーザーが指定した名前（既存データのベース名）を与え、**代わりに競合相手の方に番号サフィックスを付け直す**処理です ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly))。  
     *例:* シーン内に「Sphere」「Cube」「Cube.001」がある状態で、「Cube.001」を「Cube」にリネームしようとすると、対象だった「Cube.001」はサフィックス無しの「Cube」になり、もともと「Cube」だった方が**「Cube.001」**にリネームされます ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly)) ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=renamed%20accordingly))。結果として2つのオブジェクトの名前が入れ替わる形になり、ユーザーが意図したデータが希望通りの名前を持つことになります（この動作により、末尾番号を消すリネームが容易になっています）。  

この**「ベース名が同じ場合は入れ替え、それ以外は単独で番号付与」**という仕様変更により、Blender 4.1からはリネーム時の挙動が統一・改善されました。以前のバージョンでは、たとえば`.001`が付いた名前をベース名に変更しようとしても自動で別名にされてしまい不便でしたが、現在は上記のように賢く対処してくれます ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly))。

**内部実装について:**  
この自動リネームのロジックはBlenderの内部C言語コード（BKE/BLIライブラリ）で実装されています。データブロックの追加や名前変更の際に呼ばれる**ユニーク名生成関数**が、対象の名前空間内を検索して重複しない名称を作り出します ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=Blender%20uses%20the%20name%20to,it%20finds%20an%20unused%20name))。先述の通り基本的には「既存名+.###」という形式で最小の空き番号を探しますが、4.1での仕様変更に伴い、リネーム処理では場合によって既存データの名前の方を変更する処理（スワップ）が入るようになりました ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly))。Blenderのマニュアルにも「Blenderは自動リネーム時に他のデータブロックの名前は決して変更しない。ただしUI上のリネーム操作では特例としてベース名が同じ場合に競合するデータ同士で名前を入れ替える」と明記されています ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Blender%20will%20never%20rename%20another,002)) ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly))。  

プログラム上では、データブロック（ID）の名前フィールドに代入を行うと自動的にこのチェックが働き、名前が変更されます。そのため**Pythonスクリプト**から`bpy.data.objects["既存名"].name = "競合する名前"`のように実行した場合も、即座に`.001`付きの名前になるか、または上述の入れ替えが発生します。ユーザーは特別な処理をしなくてもBlender任せで衝突回避が行われます ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=Blender%20uses%20the%20name%20to,it%20finds%20an%20unused%20name)) ([Consider warning on duplicate node names. · Issue #93 · KhronosGroup/glTF-Validator · GitHub](https://github.com/KhronosGroup/glTF-Validator/issues/93#:~:text=or%20rename%20another%20node%20or,etc%20showing%20up))。逆に「既に存在する名前に強制的に改名する」ことはできず、どうしても必要な場合は一旦他をリネームする等の手順が必要になります ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=One%20solution%20to%20your%20problem,with%20the%20name%20you%20specify))。Blender側で名前の一意性を保証しているおかげで、アドオン開発者などは基本的に自分でユニークな名前を生成する処理を書かずに済んでいます ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=Blender%20creates%20the%20incremented%20suffixes,with%20the%20same%20name%20yourself))（Blenderが自動処理してくれるため）。  

## 4. RenameableObjectクラス設計時の考慮事項

**データブロック種別ごとの扱い:**  
複数種類のデータ（オブジェクト、ボーン、マテリアルなど）を一元的に扱ってリネーム処理を行う設計を考える場合、各データの性質とBlenderの名前空間ルールを踏まえる必要があります。すべてのrename可能な要素に共通するのは**.nameプロパティ**ですが、以下の点に注意が必要です:

- **IDデータブロックと非IDデータの差異:** オブジェクト、マテリアル、メッシュ、シーン等はすべて`bpy.types.ID`を継承する**IDデータブロック**であり、共通して`.name`プロパティや`.users`などを持ちます。一方、ボーン(`bpy.types.Bone`/`EditBone`/`PoseBone`)やノード(`bpy.types.Node`)、シーケンスストリップ(`bpy.types.Sequence`)などはIDではなく、独立した名前空間を持つ**コンテナ内要素**です。設計上、これらを統一的に扱うには、データブロックの場合と内部要素の場合で処理を分岐させるか、ラッパークラス内で抽象化する必要があります。例えば、自作の`RenameableObject`クラスで`rename(new_name)`メソッドを実装する場合、対象がIDなら単に`.name`に代入し、対象がBoneであれば所属Armature内で重複しないよう`.name`を設定する、といった内部実装が求められます。

- **Blenderの自動処理の活用:** 前述の通り、Blenderは`.name`を設定するだけで自動的にユニークな名称にしてくれます。このため、基本方針としては**Blenderの自動リネーム機構に任せる**のが簡便で安全です ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=Blender%20uses%20the%20name%20to,it%20finds%20an%20unused%20name)) ([Consider warning on duplicate node names. · Issue #93 · KhronosGroup/glTF-Validator · GitHub](https://github.com/KhronosGroup/glTF-Validator/issues/93#:~:text=or%20rename%20another%20node%20or,etc%20showing%20up))。`RenameableObject`の設計でも、原則として対象の`.name`プロパティを希望名に置き換えるだけでよく、特別な衝突検出ロジックを書かなくても問題ありません ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=Blender%20uses%20the%20name%20to,it%20finds%20an%20unused%20name))。むしろ、下手に独自で名前解決を行うとBlender内部の動きと二重になったり齟齬をきたす恐れがあります。したがって、**「IDまたは類似のオブジェクトなら.nameを書き換える」**というシンプルな実装が有効です。  

- **一貫したインターフェース:**  とはいえ、骨やノードなどIDでないものも包括してrename可能にしたい場合、設計としては共通のインターフェースを持たせることが重要です。例えば`RenameableObject`のサブクラスとして`RenameableBone`や`RenameableNode`などを用意し、それぞれ内部で適切にArmatureデータやNodeTreeにアクセスして名称変更する実装にする方法が考えられます。あるいはPythonのダックタイピングを利用し、単に`.name`属性を持つ全ての要素を受け入れる形にすることもできます。この場合でも、**Boneの場合はArmature内で重複チェック**が行われ、`PoseBone.name`に代入するとArmature中でユニークな名称に保たれることを確認しておくと良いでしょう ([Beginner tutorial: Character (rorbot) mod from scratch, in Blender | Page 2 | Rigs of Rods Community](https://forum.rigsofrods.org/threads/beginner-tutorial-character-rorbot-mod-from-scratch-in-blender.3761/page-2#:~:text=Step%2025%20,new%20bone))。実際、`EditBone.name`や`PoseBone.name`を設定するとBlenderは同一Armature内の他ボーンと衝突しないよう自動処理します。

- **リネーム処理の粒度:**  すべてのデータブロックを抽象化して扱うと、一見同じ`.name`操作で済むように思えますが、状況によっては追加処理が必要になります。例えば、**リンクデータ**（外部ライブラリから読み込まれたデータブロック）は`.name`が読み取り専用で変更できないため、リネームするにはまずローカルコピー化（`make_local()`）する必要があります ([How Blender handles name collision? - Archive - Developer Forum](https://devtalk.blender.org/t/how-blender-handles-name-collision/24593#:~:text=Indeed%20in%20Blender%20two%20objects,able%20to%20process%20them%20properly))。また、ボーン名変更時には前述した頂点グループ名など関連データの整合性、ノード名変更時にはスクリプトやドライバーでそのノード名を参照している可能性など、**コンテキスト依存の注意**があります。従って、RenameableObjectの設計では「単に名前文字列を変える」以上の処理が必要かどうかをデータ種別ごとに検討します。必要なら、例えば`rename()`実行時に対象がArmatureのボーンなら関連オブジェクトの頂点グループもリネームする、といった仕組みを組み込むことも考えられます。

- **命名規則の統一:** 複数種類のデータを一括リネームするケースでは、命名ポリシーの統一も考慮します。Blenderは基本「衝突したら.数字を付ける」ですが、プロジェクトによっては別の命名規則（例えば接頭辞としてオブジェクト種別を付ける等）を使いたい場合もあるでしょう。そのような場合、RenameableObject内で新規名生成のルール（例えば`<種別>_<ベース名>`形式にする等）を持たせ、**Blenderの自動命名に頼らず**意図的にユニーク名を作ってから`.name`に適用する方法もあります。ただし、これもBlenderの仕組みと二重にならないよう注意が必要です。Blenderは`.name`代入時に即リネームするため、**スクリプト側で生成した名前が既存とかぶっていないか**をチェックするか、あるいは一度Blenderに付けさせた後で自前ルールに沿ってさらに調整する、といった段取りが考えられます。

要約すると、RenameableObjectの設計では**Blenderの名前空間ごとのユニーク性ルール**を正しく把握し、それに沿って動作させることが重要です。各データブロックは**Blender内部で一意名を保証**しているので、それを信用して実装を簡潔にするのが得策です。また、UIの仕様（4.1でのスワップ動作など）も念頭に置いて、必要ならそれを再現するロジックを組み込むこともできます。例えば、`.001`が付いた名前をベース名に変更する処理を自動化したい場合、まず対象の名前をベース名にし、同名の既存データを探してそれに“.001”を付ける、といった処理を自前で行うことでUIと同じ結果を得ることも可能です。

## 5. 関連ドキュメント・APIリファレンス・コミュニティ情報

調査に利用した、あるいは参考になる公式ドキュメントやコミュニティ情報を以下にまとめます。

- **Blender公式マニュアル:**  
  - 「**データブロック (Data-Blocks)**」: Blenderのデータ構造と命名規則について記載。特に「Name & Rename」セクションに名前空間ごとの一意性や“.001”付与ルールの説明があります ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Data,blendfile%20it%20is%20stored%20in)) ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=When%20Blender%20has%20to%20name,until%20no%20collision%20happen%20anymore))。  
  - 「**Rename（リネーム）**」: Blender 4.3マニュアルの該当ページ。F2キーで起動する「Rename Active Item」オペレーターの説明 ([Rename - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/blend/rename.html#:~:text=The%20Rename%20Active%20Item%20operator,Object%20%20and%20%201838))や、Batch Rename機能の解説があります。リネーム時の挙動（4.1で変更された内容）についても記述があります ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,the%20first%20available%20numerical%20suffix)) ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=,block%20is%20renamed%20accordingly))。  
  - 「**Armatures > Bones > Editing > Naming**」(ボーンの命名): ボーンの名前の付け方や左右対称の命名規則(.L/.Rなど)についてガイドしています ([Naming — Blender Manual](https://docs.blender.org/manual/ko/2.90/animation/armatures/bones/editing/naming.html#:~:text=You%20can%20rename%20your%20bones%2C,clicking%20bones%20in%20the%20Outliner)) ([Naming — Blender Manual](https://docs.blender.org/manual/ko/2.90/animation/armatures/bones/editing/naming.html#:~:text=Naming%20conventions%20in%20Blender%20are,two%20of%20them%20are%20counterparts))。Blenderで左右対称な名前を使うとミラー編集やX軸対称等でメリットがあることが書かれています。  
  - 「**Life Time（データブロックの寿命）**」: 余談ですが、使われなくなったデータブロックが.blend保存時に削除される仕様やシールドアイコン（データの擬似的保護）について触れています ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Every%20data,unused%20data%20is%20eventually%20removed)) ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=To%20protect%20a%20data,manually%20remove%20it%20if%20needed))。名前管理とは直接関係ありませんが、データブロックの基本仕様として知っておくと良いでしょう。

- **Blender Python APIリファレンス:**  
  - `bpy.types.ID`: オブジェクト、マテリアル等すべてのIDデータブロックの基底クラス。`.name`プロパティ（文字列）を持ち、これを書き換えることでリネーム可能です ([outliner - What is the format for object names in Blender and are there any limitations? - Blender Stack Exchange](https://blender.stackexchange.com/questions/24245/what-is-the-format-for-object-names-in-blender-and-are-there-any-limitations#:~:text=1,texture%20with%20the%20same%20names))。IDクラス自体のドキュメントは簡潔ですが、各具体的なクラス（ObjectやMesh等）のプロパティ欄に`.name`が記載されています。  
  - `bpy.types.EditBone` / `bpy.types.PoseBone`: ボーンに関するAPI。`.name`プロパティやその他骨特有の属性が説明されています（例: `EditBone.name` ([EditBone(bpy_struct) - Blender Python API](https://docs.blender.org/api/current/bpy.types.EditBone.html#:~:text=0,0))、`PoseBone.name` ([PoseBone(bpy_struct) - Blender Python API](https://docs.blender.org/api/current/bpy.types.PoseBone.html#:~:text=MotionPath%2C%20))）。`.name`は読み書き可能で、PoseBoneの場合それを変えるとArmatureデータ上の名前が変わる点に注意です。また、`PoseBone.bone`で対応するArmature内の`Bone`データにアクセスできます ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Note))。  
  - Blender公式サイトの「**Gotchas: Bones & Armatures**」: Python APIドキュメント内のTips集で、編集モードとポーズモードでアクセスできるボーンデータの違いについて解説しています ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Edit%20Bones%2C%20Pose%20Bones%2C%20Bone%E2%80%A6,Bones%C2%B6)) ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Note))。この中で「ArmatureのボーンはEditBone, Bone, PoseBoneという3種類のデータ構造がある」ことが説明されています ([Bones & Armatures - Blender Python API](https://docs.blender.org/api/4.4/info_gotchas_armatures_and_bones.html#:~:text=Edit%20Bones%2C%20Pose%20Bones%2C%20Bone%E2%80%A6,Bones%C2%B6))。

- **Blender開発者フォーラム/コミュニティ情報:**  
  - Blender DevtalkのQA「**How Blender handles name collision?**」: アドオン開発者からの質問で、名前衝突時の挙動や`.append`でのリネームについて議論されています ([How Blender handles name collision? - Archive - Developer Forum](https://devtalk.blender.org/t/how-blender-handles-name-collision/24593#:~:text=Indeed%20in%20Blender%20two%20objects,able%20to%20process%20them%20properly))。具体的な解決策は示されていませんが、「Blenderでは2つのオブジェクトが同じ名前を持てず、`.001`が付く」「Append時も同様」という確認がなされています ([How Blender handles name collision? - Archive - Developer Forum](https://devtalk.blender.org/t/how-blender-handles-name-collision/24593#:~:text=Indeed%20in%20Blender%20two%20objects,able%20to%20process%20them%20properly))。  
  - Khronos glTF Validatorのissue「**Consider warning on duplicate node names**」: Blender開発者もコメントしており、「Blenderでは名前は種類ごとにユニークで、同じ種類内で重複させようとするとCube.001等が付与される」という説明があります ([Consider warning on duplicate node names. · Issue #93 · KhronosGroup/glTF-Validator · GitHub](https://github.com/KhronosGroup/glTF-Validator/issues/93#:~:text=For%20reference%2C%20Blender%20names%20are,etc%20showing%20up))。Blenderが内部で強制的にユニーク性を保証するため、インポーター側で特別な対処は不要だろう、といった内容です ([Consider warning on duplicate node names. · Issue #93 · KhronosGroup/glTF-Validator · GitHub](https://github.com/KhronosGroup/glTF-Validator/issues/93#:~:text=or%20rename%20another%20node%20or,etc%20showing%20up))。  
  - Blender Stack Exchange Q&A:  
    - 「**Explicitly setting object name to X sets it to X.001?**」: Pythonでオブジェクト名を設定すると勝手に“.001”になる質問に対し、**Blenderでは名前がIDとして使われるため重複を許さない**こと、重複する場合自動で“.001”等を付ける仕様であることが解説されています ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=Blender%20uses%20the%20name%20to,it%20finds%20an%20unused%20name))。回答では、「スクリプトで特定名を保証したければ、既存オブジェクトを事前にリネーム/削除するか、新規作成後にrenameを2段階で行う（1回目で“.001”が付いた後にもう一度設定して既存の方を“.001”にずらす）」といったテクニックもコメントされています ([python - Explicitly setting object name to "X" actually sets it to "X.001"? - Blender Stack Exchange](https://blender.stackexchange.com/questions/112757/explicitly-setting-object-name-to-x-actually-sets-it-to-x-001#:~:text=1))。  
    - 「**What is the format for object names and limitations?**」: Blenderの名前に使えない文字はあるか、長さ制限は、同名は可能か等の質問に対し、モデレーターのMont29氏が回答したもの ([outliner - What is the format for object names in Blender and are there any limitations? - Blender Stack Exchange](https://blender.stackexchange.com/questions/24245/what-is-the-format-for-object-names-in-blender-and-are-there-any-limitations#:~:text=%24))。内容は「63バイト制限」「基本どんな文字も使用可（内部的にはUTF-8）」「同種内で同名不可（自動で.001が付く）、異なる種類なら同名OK」といったもので、名前仕様の要点がまとまっています ([outliner - What is the format for object names in Blender and are there any limitations? - Blender Stack Exchange](https://blender.stackexchange.com/questions/24245/what-is-the-format-for-object-names-in-blender-and-are-there-any-limitations#:~:text=Any%20ID%20name%20,use%20two%20bytes%20or%20more))。  
    - その他、「Batch Renameの使い方」「複数オブジェクトのリネーム挙動」等に関するQAもあります。例えばBlender 4以降のリネーム挙動変更について「Pre 4.1のリネーム動作が恋しい」という意見もReddit等で出ていますが ([How to revert to old object renaming system : r/blenderhelp - Reddit](https://www.reddit.com/r/blenderhelp/comments/1e5ud78/how_to_revert_to_old_object_renaming_system/#:~:text=How%20to%20revert%20to%20old,automatically%20changing%20the%20other%20object))、現在は上述の通り改善されているため、基本的にBlender標準の挙動に従うのが良いでしょう。

- **ソースコード参照:**  
  Blenderのソースコード自体はC/C++で書かれており、命名衝突処理は`blenkernel`や`blenlib`モジュール内で行われています。関数名で言えば、IDデータブロックの名前重複を解決する`BKE_id_new_name`やユニーク名生成用の`BLI_uniquename`といった関数が存在し、これらが新規追加や名前変更時に呼ばれます。実際のコードを見る場合、Blender公式のprojects.blender.orgやGitHubミラー上で「`BLI_uniquename`」等を検索すると該当箇所を確認できます。例えば、`.001`という文字列がどのように付与されているか興味があれば、Blenderソース中の文字列操作部分（`BLI_string`関連）やID名管理部分を追ってみると良いでしょう。もっとも、通常は公式ドキュメントの情報だけで十分かと思われます。

以上のドキュメントや情報源を参照することで、Blender 4.3以降の名前空間管理と命名衝突回避について体系的に理解できます。特に公式マニュアル ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=Data,blendfile%20it%20is%20stored%20in)) ([Data-Blocks - Blender 4.3 Manual](https://docs.blender.org/manual/en/latest/files/data_blocks.html#:~:text=When%20Blender%20has%20to%20name,until%20no%20collision%20happen%20anymore))とAPIリファレンス、そしてMont29氏の解説 ([outliner - What is the format for object names in Blender and are there any limitations? - Blender Stack Exchange](https://blender.stackexchange.com/questions/24245/what-is-the-format-for-object-names-in-blender-and-are-there-any-limitations#:~:text=1,texture%20with%20the%20same%20names))は要点がまとまっており有用です。コミュニティのQ&Aも実践的な視点で補足しているので、具体的なケースに応じて参考にしてください。

